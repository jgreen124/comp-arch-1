#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <thread>
#include <fstream>
#include <cmath>
#include <fstream>

#include "square_root_serial.h"
#include "square_root_ispc.h"   // generated by ispc -h
#include "square_root_avx.h" 
using namespace std;
using namespace std::chrono;
using namespace ispc;

// Helper for timing (returns seconds)
template<class F>
double time_sec(F&& f) {
    auto t1 = high_resolution_clock::now();
    f();
    auto t2 = high_resolution_clock::now();
    return duration<double>(t2 - t1).count();
}

// Open CSV in append mode, write header if needed
static ofstream open_csv_append_with_header(const string& path) {
    bool need_header = false;
    {
        ifstream test(path);
        if (!test.good() || test.peek() == ifstream::traits_type::eof()) {
            need_header = true;
        }
    }
    ofstream csv(path, ios::app);
    if (need_header) {
        csv << "mode,threads,N,time_s,speedup_vs_serial\n";
    }
    return csv;
}

// Run ISPC helpers
static void run_ispc_slice(const float* in, float* out, int start, int end) {
    const int len = end - start;
    if (len > 0) {
        square_root_ispc(in + start, out + start, len);
    }
}

static void run_avx_slice(const float* in, float* out, int start, int end) {
    const int len = end - start;
    if (len > 0) {
        square_root_avx(in + start, out + start, len);
    }
}

int main() {
    const int N = 10'000'000;    
    vector<float> in(N), out_serial(N), out_ispc(N), out_avx(N),
                  out_ispc_threads(N), out_avx_threads(N);

    // Deterministic input in [0,8]
    mt19937 gen(0);
    uniform_real_distribution<float> dist(0.0f, 8.0f);
    for (int i = 0; i < N; ++i) in[i] = dist(gen);

    cout << "Computing square roots for " << N << " numbers...\n";

    // Serial baseline
    double t_serial = time_sec([&]{
        square_root_serial(in.data(), out_serial.data(), N);
    });
    cout << "Serial time: " << t_serial << " s\n";

    // ISPC Single-core SIMD
    double t_ispc = time_sec([&]{
        square_root_ispc(in.data(), out_ispc.data(), N);
    });
    double maxErrISPC = 0.0;
    for (int i = 0; i < N; ++i) {
        double d = std::fabs((double)out_serial[i] - (double)out_ispc[i]);
        if (d > maxErrISPC) maxErrISPC = d;
    }
    cout << "Max error (ISPC vs Serial): " << maxErrISPC << "\n";
    cout << "ISPC SIMD time: " << t_ispc
         << " s (speedup " << (t_serial / t_ispc) << "x)\n";

    // AVX2 intrinsics for single-core
    double t_avx = time_sec([&]{
        square_root_avx(in.data(), out_avx.data(), N);
    });
    double maxErrAVX = 0.0;
    for (int i = 0; i < N; ++i) {
        double d = std::fabs((double)out_serial[i] - (double)out_avx[i]);
        if (d > maxErrAVX) maxErrAVX = d;
    }
    cout << "Max error (AVX vs Serial): " << maxErrAVX << "\n";
    cout << "AVX2 time: " << t_avx
         << " s (speedup " << (t_serial / t_avx) << "x)\n";

// CSV loggin
    auto csv = open_csv_append_with_header("perf_results.csv");
    csv << "serial,1,"      << N << "," << t_serial << ",1.0\n";
    csv << "ispc_simd,1,"   << N << "," << t_ispc   << "," << (t_serial/t_ispc) << "\n";
    csv << "avx_intrin,1,"  << N << "," << t_avx    << "," << (t_serial/t_avx)  << "\n";

// ISPC multicore
    cout << "\n=== Multicore via host threads (ISPC per-slice) ===\n";
    cout << "Threads\tTime (s)\tSpeedup vs Serial\tSpeedup vs ISPC(1)\n";
    for (int T : {1,2,3,4,5,6,7,8}) {
        int chunk = (N + T - 1) / T;
        double t_mc = time_sec([&]{
            vector<thread> ths;
            ths.reserve(T);
            for (int tid = 0; tid < T; ++tid) {
                int start = tid * chunk;
                int end   = std::min(N, start + chunk);
                ths.emplace_back(run_ispc_slice, in.data(), out_ispc_threads.data(), start, end);
            }
            for (auto& th : ths) th.join();
        });
        cout << T << '\t' << t_mc << '\t'
             << (t_serial / t_mc) << "x\t\t"
             << (t_ispc   / t_mc) << "x\n";
        csv << "ispc_threads," << T << "," << N << "," << t_mc << "," << (t_serial/t_mc) << "\n";
    }

    // AVX multicore
    cout << "\n=== Multicore via host threads (AVX2 per-slice) ===\n";
    cout << "Threads\tTime (s)\tSpeedup vs Serial\tSpeedup vs AVX(1)\n";
    for (int T : {1,2,3,4,5,6,7,8}) {
        int chunk = (N + T - 1) / T;
        double t_mc = time_sec([&]{
            vector<thread> ths;
            ths.reserve(T);
            for (int tid = 0; tid < T; ++tid) {
                int start = tid * chunk;
                int end   = std::min(N, start + chunk);
                ths.emplace_back(run_avx_slice, in.data(), out_avx_threads.data(), start, end);
            }
            for (auto& th : ths) th.join();
        });
        cout << T << '\t' << t_mc << '\t'
             << (t_serial / t_mc) << "x\t\t"
             << (t_avx    / t_mc) << "x\n";
        csv << "avx_threads," << T << "," << N << "," << t_mc << "," << (t_serial/t_mc) << "\n";
    }

    csv.close();
    cout << "\nAppended results to perf_results.csv\n";
    cout << "Done.\n";
    return 0;
}
